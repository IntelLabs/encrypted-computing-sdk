<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Encrypted Computing SDK: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Encrypted Computing SDK
   </div>
   <div id="projectbrief">A modular LLVM-inspired compiler pipeline that enables FHE implementations on HW accelerators like Intel&#39;s HERACLES .</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is the kernel generator (<code>kerngen</code>) responsible for producing HERACLES ISA kernels for various polynomial operations that occur in cryptography (or elsewhere) such as in homomorphic encryption (HE). A kernel is a code snippet of P-ISA instructions with the purpose of implementing some high level polynomial operation.</p>
<h1><a class="anchor" id="autotoc_md192"></a>
Dependencies</h1>
<p><code>kerngen</code> is written as a pure python program. Requirements required to be installed,</p>
<ul>
<li>python &gt;= 3.10</li>
<li>pip (recommend &gt;= 24.0)</li>
<li>and python <a href="./requirements.txt">requirements</a>.</li>
</ul>
<p>To install the python dependencies and development tools simply run,</p>
<div class="fragment"><div class="line">pip install -r requirements.txt</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md193"></a>
Implementation</h1>
<h2><a class="anchor" id="autotoc_md194"></a>
Overview</h2>
<p>The design is a simplified interpreter pattern. A domain specific language defined as a 'kernel language' is received as input to the kernel generator. This kernel language describes (which can be used for HE schemes) operations on polynomials with given context parameters. This language is interpreted as a <code>high level instruction</code> which is then mapped to its corresponding <code>low level P-ISA instruction</code>. <code>kerngen</code> uses a common unix command line utility convention and the resulting P-ISA kernel is sent to <code>stdout</code>.</p>
<h2><a class="anchor" id="autotoc_md195"></a>
Internals</h2>
<p>Under the <code>high_parser</code> directory is the core of the <code>kerngen</code> logic with the principal classes being <code>Parser</code> and <code>Generator</code>. For completeness, we take a quick look through the files.</p>
<ul>
<li><code>__init__.py</code> is worth a mention because it contains imports to the most commonly used types. This makes it easier to import those types from the top level including when writing kernels e.g. <code>from high_parser import Polys</code>.</li>
<li><code>config.py</code> is a minor file primarily containing the <code>Config</code> class. The class itself is used as a global singleton object to hold configuration information of <code>kerngen</code>. It was introduced to not disturb the existing APIs while changing global behaviour i.e. a legacy mode.</li>
<li><code><a class="el" href="generators_8py.html">generators.py</a></code> contains the <code>Generator</code> class responsible for dealing with the manifest file and loading the appropriate kernel class. Instances of <code>Parser</code> have an instance of this class for a given manifest file. Instances should be created using the factory class method <code>from_manifest</code> and providing the path to the manifest file and a <code>scheme</code>. Although it is referred to as <code>scheme</code> it is in fact just a key label mapping to a collection of grouped kernels. Lookup can then be performed using <code>get_kernel</code> given a valid kernel operation name.</li>
<li><code>parser.py</code> contains <code>Parser</code> responsible for parsing the input kernel language and creating the correct corresponding command objects for the interpreter to process. The output of parsing is given by an instance of <code>ParserResult</code>, an object containing all the parsed information. Note that the object is lazy in generating the P-ISA operations which are returned as a python generator when the <code>get_pisa_ops</code> method is called. Note that one current peculiarity is that once a parser is instantiated that a generator must be set before parsing can be done. This is a current limitation that <code>kerngen</code> currently can only have kernels defined under the <code>pisa_generators</code> directory.</li>
<li><code><a class="el" href="pisa__operations_8py.html">pisa_operations.py</a></code> contains all the known P-ISA operations. These are essentially objects that are responsible for formatting the operation strings for <code>kerngen</code> outputs. The class names reflect the P-ISA operations as closely as possible.</li>
<li><code><a class="el" href="types_8py.html">types.py</a></code> has many types used by <code>kerngen</code> by the <code>Parser</code> and by kernel classes. This is where the parser types are implemented, namely, <code>Context</code>, <code>Data</code>, <code>EmptyLine</code>, <code>Comment</code>, <code>Immediate</code>, <code>HighOp</code>. Note that <code>HighOp</code> is the class that all kernels inherit from. The other main type of note that is implemented here is the <code>Polys</code> class. This is the type that is heavily utilized by kernel writers to represent polynomials. At the most basic, these polynomial objects contain: a <code>part</code>, elements/coefficients of the high-level data structure which themselves represent polynomials; an <code>rns</code> number that describes up to how many RNS numbers a <code>part</code> is decomposed by; and a <code>unit</code> represents how many units (a.k.a. a block) a <code>part</code> has to be divided by. The <code>unit</code> is both an underlying hardware division, but also for NTT operations to work a <code>part</code>, the <code>part</code> must be at least split in two to feed in as inputs to the operation.</li>
</ul>
<h1><a class="anchor" id="autotoc_md196"></a>
Input kernel language</h1>
<p>There are several kinds of commands. Keywords that cannot be used for kernel names, </p><div class="fragment"><div class="line">- `CONTEXT`</div>
<div class="line">- `DATA`</div>
<div class="line">- `IMM`</div>
</div><!-- fragment --><p>All other commands are assumed to be operations. All operations are case insensitive, but the convention we use is the operations are capitalized. These are defined in the <a href="./pisa_generators/manifest.json">manifest.json</a> file. </p><div class="fragment"><div class="line">CONTEXT BGV 8192 4 3</div>
<div class="line">DATA a 2</div>
<div class="line">DATA b 2</div>
<div class="line">DATA c 2</div>
<div class="line">ADD c a b</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md197"></a>
CONTEXT</h2>
<p>Context defines the global properties <code>(scheme, poly_ring_dimension, max_rns, current_rns)</code> of the input script. <code>CONTEXT</code> sets a global context for properties required by the kernels.</p><ul>
<li>first field defines what we call scheme. In reality, it specifies the set of kernel instructions given in the manifest file, see <a href="./pisa_generators/manifest.json">manifest.json</a>.</li>
<li>second field defines the polynomial size for the <code>DATA</code>. This is required by the generating kernels to define how many units (multiples of the native polynomial size, 8192 in HERACLES silicon case) are required and handled.</li>
<li>third field defines the key RNS, i.e. the total max RNS of the relinearization key, typically the global max number of how many 32 bit prime number moduli (HERACLES silicon case) are in the modulus chain that the kernels can have or need to handle + 1.</li>
<li>fourth field defines the number of RNS terms in the current polynomial.</li>
</ul>
<h2><a class="anchor" id="autotoc_md198"></a>
DATA</h2>
<p><code>DATA</code> defines polynomial symbols to be used and their attribute(s) (<code>num_parts</code>) where <code>num_parts</code> is the number of polynomials that comprise the data variable.</p>
<h2><a class="anchor" id="autotoc_md199"></a>
IMMEDIATE</h2>
<p><code>IMM</code> declares a fixed symbol name that can be used for operations that expect and immediate value(s).</p>
<h1><a class="anchor" id="autotoc_md200"></a>
Generating kernels</h1>
<p>The main entry point to the kernel generator is <a href="kerngen.py">kerngen.py</a>. This script expects input from <code>stdin</code> in the form of the input high language described above. It can be called with </p><div class="fragment"><div class="line">./kerngen.py &lt; addition.data</div>
</div><!-- fragment --><p> where <code>addition.data</code> is a text file containing the high language for an <code>ADD</code> operation.</p>
<p>The kernel generator prints two comments, a context and kernel descriptor respectively, followed by the P-ISA kernel. If desired, the comments can be disabled by passing the <code>-q</code> or <code>--quiet</code> flag to the kernel generator, i.e., </p><div class="fragment"><div class="line">./kerngen.py -q &lt; addition.data</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md201"></a>
Adding new kernel generators</h1>
<p>You can add new kernel generators that you have developed by creating a class that inherits from the <code>HighOp</code> abstract class (interface) and implementing the <code>to_pisa</code> method; turning this instruction into a P-ISA instruction class. Examples can be seen in the simpler implementations given in <a href="./pisa_generators/basic.py">basic.py</a>. Also, provide a class method <code>from_string</code> that will be passed the args for that command.</p>
<p>For <code>kerngen</code> to know of your class that represents a new command of the high language, simply add an entry into the JSON object in the <a href="./pisa_generators/manifest.json">manifest.json</a> file. The key of the outermost JSON object is the FHE scheme <code>{BGV, CKKS, ...}</code>; this key corresponds to a set of associated operations. Each operation (inner JSON object) consists of the operation name <code>OPNAME</code> as its key and a list containing the class name as the first entry and the file it is located in as its second. e.g. </p><div class="fragment"><div class="line">{</div>
<div class="line">  &quot;SCHEME&quot;: {</div>
<div class="line">    &quot;OPNAME&quot;: [&quot;ClassName&quot;, &quot;filename.py&quot;]</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>For kernel writers the reserved words that cannot be used as <code>OPNAME</code> are: </p><div class="fragment"><div class="line">- CONTEXT</div>
<div class="line">- DATA</div>
<div class="line">- IMM</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md202"></a>
Writing kernels</h1>
<p>The kernel generator has been designed to make it easy to add new kernels. Kernel files are typically placed in the <a href="./pisa_generators">pisa_generators</a> directory to simplify the manifest file as the paths are relative to this directory.</p>
<p>Before writing the kernel you will require to import the <code>pisa_operations</code> module and any relevant types from the <code>high_parser</code> such as the <code>HighOp</code> and <code>Context</code> </p><div class="fragment"><div class="line">import high_parser.pisa_operations as pisa_op</div>
<div class="line">from high_parser.pisa_operations import PIsaOp</div>
<div class="line">from high_parser import Context, HighOp, Polys</div>
</div><!-- fragment --><p>The <code>Polys</code> class will be the most commonly used type in most kernels to represent the inputs and outputs of the operation. This type represents the polynomials and holds information such as the <code>name</code> of symbol that represents the polynomial, the number of <code>parts</code>, and the <code>rns</code>.</p>
<p>At a high level kernels convert high-level operations into low-level P-ISA operations, thus all kernels will need to inherit from <code>HighOp</code> and define the conversion function <code>to_pisa</code> as follows </p><div class="fragment"><div class="line">@dataclass</div>
<div class="line">class NewKernel(HighOp):</div>
<div class="line">    &quot;&quot;&quot;Class representing the high-level NewKernel operation&quot;&quot;&quot;</div>
<div class="line"> </div>
<div class="line">    context: Context</div>
<div class="line">    output: Polys</div>
<div class="line">    input0: Polys</div>
<div class="line"> </div>
<div class="line">    def to_pisa(self) -&gt; list[PIsaOp]:</div>
<div class="line">        &quot;&quot;&quot;Return the p-ISA equivalent of the NewKernel operation&quot;&quot;&quot;</div>
</div><!-- fragment --><p>If the kernel consists of an algorithm already represented by an existing kernel it is possible to import the necessary kernel and compose the new kernel using existing kernels. For example the <code>Square</code> kernel requires a <code>Mul</code> operation </p><div class="fragment"><div class="line">from .basic import Mul</div>
<div class="line"> </div>
<div class="line">class Square(HighOp):</div>
<div class="line">...</div>
<div class="line">mul = Mul(...)</div>
</div><!-- fragment --><p> see <a href="./pisa_generators/square.py">square.py</a> for a complete example of this.</p>
<h1><a class="anchor" id="autotoc_md203"></a>
Mixed operations</h1>
<p>You will find that during kernel writing, you will end up with a collection of either P-ISA operation objects, other kernel objects, or a mixture of both. For your convenience a useful function <code>mixed_to_pisa_ops</code> is provided that can take all of these sequentially and outputs the required <code>list[PIsaOp]</code>.</p>
<h1><a class="anchor" id="autotoc_md204"></a>
Running the tests</h1>
<p>Tests are provided in the <a href="./tests">tests</a> directory and use the <a href="https://pypi.org/project/pytest/">pytest</a> framework. To run the tests run the following </p><div class="fragment"><div class="line">pytest &lt;test-directory&gt;</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
